CONST const
ID NU
EQUAL =
INT 123456
SEMICOLON ;
VAR var
ID i
COLON :
INTEGER integer
SEMICOLON ;
ID a
BECOME :=
CHAR char
SEMICOLON ;
PROCEDRUE procedure
ID test
LPAR (
ID p
COLON :
INTEGER integer
SEMICOLON ;
VAR var
ID t
COLON :
CHAR char
RPAR )
SEMICOLON ;
VAR var
ID sw
COMMA ,
ID i
COMMA ,
ID j
COLON :
INTEGER integer
SEMICOLON ;
FUNCTION function
ID xtest1
LPAR (
ID i
COLON :
INTEGER integer
COMMA ,
VAR var
ID j
COLON :
INTEGER integer
RPAR )
COLON :
INTEGER integer
SEMICOLON ;
VAR var
ID re
COMMA ,
ID a
COLON :
INTEGER integer
SEMICOLON ;
BEGIN begin
IF if
ID i
LESS <
ID j
THEN then
ID re
BECOME :=
ID xtest1
LPAR (
ID j
COMMA ,
ID i
RPAR )
ELSESY else
BEGIN begin
IF if
ID j
EQUAL =
INT 0
THEN then
ID xtest1
BECOME :=
ID i
ELSESY else
BEGIN begin
ID a
BECOME :=
ID j
SEMICOLON ;
ID j
BECOME :=
ID i
MINUS -
ID i
DIVI /
ID j
STAR *
ID j
SEMICOLON ;
ID i
BECOME :=
ID a
SEMICOLON ;
ID re
BECOME :=
ID xtext1
LPAR (
ID i
COMMA ,
ID j
RPAR )
END end
END end
END end
SEMICOLON ;
PROCEDRUE procedure
ID xtest2
LPAR (
ID a
COLON :
INTEGER integer
RPAR )
SEMICOLON ;
CONST const
ID N
BECOME :=
INT 5
SEMICOLON ;
VAR var
ID i
COLON :
INTEGER integer
SEMICOLON ;
ID s
BECOME :=
ARRAY array
LBRACKET [
INT 10
RBRACKET ]
OF of
INTEGER integer
SEMICOLON ;
BEGIN begin
FOR for
ID i
BECOME :=
INT 0
TO to
ID N
MINUS -
INT 1
DO do
BEGIN begin
ID s
LBRACKET [
ID i
RBRACKET ]
BECOME :=
ID a
SEMICOLON ;
ID a
BECOME :=
ID a
PLUS +
INT 1
END end
SEMICOLON ;
FOR for
ID i
BECOME :=
ID N
MINUS -
INT 1
DOWNTO downto
INT 0
DO do
BEGIN begin
WRITE write
LPAR (
ID s
LBRACKET [
ID i
RBRACKET ]
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
END end
END end
SEMICOLON ;
PROCEDRUE procedure
ID xtest3
SEMICOLON ;
VAR var
ID ch
COLON :
CHAR char
SEMICOLON ;
BEGIN begin
ID ch
BECOME :=
CHAR h
SEMICOLON ;
WRITE write
LPAR (
STRING ~!@#$%^&*()
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID NU
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING => 
COMMA ,
ID ch
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
END end
SEMICOLON ;
BEGIN begin
READ read
LPAR (
ID sw
RPAR )
SEMICOLON ;
CASE case
ID sw
OF of
INT 1
COLON :
BEGIN begin
READ read
LPAR (
ID i
COMMA ,
ID j
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID xtest1
LPAR (
ID i
COMMA ,
ID j
RPAR )
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID i
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID j
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
END end
SEMICOLON ;
INT 2
COLON :
BEGIN begin
READ read
LPAR (
ID i
RPAR )
SEMICOLON ;
ID xtest2
LPAR (
ID i
RPAR )
END end
SEMICOLON ;
INT 3
COLON :
ID xtest3
SEMICOLON ;
INT 4
COLON :
BEGIN begin
WRITE write
LPAR (
ID p
PLUS +
ID t
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
ID t
BECOME :=
CHAR 0
SEMICOLON ;
WRITE write
LPAR (
ID t
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
END end
END end
END end
SEMICOLON ;
BEGIN begin
ID a
BECOME :=
CHAR a
SEMICOLON ;
READ read
LPAR (
ID i
RPAR )
SEMICOLON ;
ID test
LPAR (
ID i
COMMA ,
ID a
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID i
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
SEMICOLON ;
WRITE write
LPAR (
ID a
RPAR )
SEMICOLON ;
WRITE write
LPAR (
STRING  
RPAR )
END end
PERIOD .
